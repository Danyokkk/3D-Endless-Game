<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Driver HD</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #FFA500;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background-color: #4a4a4a; /* Brighter asphalt color */
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .info-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2rem;
            z-index: 5;
        }
        .info-bar span {
            background: #111;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 30px var(--primary-color);
            z-index: 10;
        }
        .modal h2 {
            margin-top: 0;
            font-size: 2.5rem;
            color: var(--primary-color);
        }
        .modal p {
            font-size: 1.2rem;
        }
        .button {
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: var(--primary-color);
            color: #1a1a1a;
            border: none;
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            box-shadow: 0 0 15px var(--primary-color);
            transition: all 0.2s ease;
        }
        .button:hover {
            background-color: #fff;
            color: #000;
            box-shadow: 0 0 25px var(--primary-color);
        }
        #car-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .car-option {
            width: 50px;
            height: 90px;
            border: 3px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .car-option:hover, .car-option.selected {
            border-color: var(--primary-color);
            transform: scale(1.1);
        }
    </style>
</head>
<body>

<div id="splash-screen" class="modal">
    <h2>Made by Danik</h2>
</div>

<div id="start-menu" class="modal" style="display: none;">
    <h2>Endless Driver HD</h2>
    <p>Select your car:</p>
    <div id="car-selection">
        <div class="car-option" data-color="#1E1E1E" style="background-color: #1E1E1E;"></div>
        <div class="car-option" data-color="#B22222" style="background-color: #B22222;"></div>
        <div class="car-option" data-color="#1E90FF" style="background-color: #1E90FF;"></div>
        <div class="car-option" data-color="#228B22" style="background-color: #228B22;"></div>
        <div class="car-option" data-color="#8A2BE2" style="background-color: #8A2BE2;"></div>
        <div class="car-option" data-color="#FF8C00" style="background-color: #FF8C00;"></div>
        <div class="car-option" data-color="#F5F5F5" style="background-color: #F5F5F5;"></div>
    </div>
    <button id="start-button" class="button">Start Game</button>
</div>

<div class="game-container" id="game-area" style="display: none;">
    <div class="info-bar">
        <span id="score">Score: 0</span>
        <span id="high-score">Best: 0</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-over-menu" class="modal" style="display: none;">
        <h2>Game Over</h2>
        <p id="final-score">Your Score: 0</p>
        <button id="restart-button" class="button">Restart</button>
    </div>
</div>

<script type="module">
    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('high-score');
    const startMenu = document.getElementById('start-menu');
    const gameOverMenu = document.getElementById('game-over-menu');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    const startButton = document.getElementById('start-button');
    const carSelectionContainer = document.getElementById('car-selection');
    const gameArea = document.getElementById('game-area');
    const splashScreen = document.getElementById('splash-screen');

    // --- Splash Screen Logic ---
    window.addEventListener('load', () => {
        setTimeout(() => {
            splashScreen.style.display = 'none';
            startMenu.style.display = 'block';
        }, 2500); // Show splash for 2.5 seconds
    });

    // --- Audio ---
    let audioCtx;
    let engineSound;

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playEngineSound() {
        if(!audioCtx) return;
        if (engineSound) {
            engineSound.stop();
        }
        engineSound = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        engineSound.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        engineSound.type = 'sawtooth';
        gainNode.gain.value = 0.05; // Keep volume low
        engineSound.frequency.value = 60; // Base pitch
        engineSound.start();
    }
    
    function playCrashSound() {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'noise';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.5);
    }
    
    function updateEnginePitch(currentSpeed) {
        if (!engineSound) return;
        const basePitch = 60;
        const maxPitch = 120;
        const pitch = basePitch + (currentSpeed / maxSpeed) * (maxPitch - basePitch);
        engineSound.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
    }

    // --- Game Configuration ---
    let gameWidth, gameHeight;
    const carWidth = 50;
    const carHeight = 90;
    const speedIncreaseInterval = 20;
    const initialSpeed = 4;
    const maxSpeed = 18;

    // --- Game State ---
    let car, obstacles, roadMarkings, skidMarks;
    let score, highScore, speed, lastSpeedIncreaseScore, selectedCarColor;
    let gameOver;
    let animationFrameId;
    let keys = {};
    
    // --- Car Physics ---
    const carPhysics = {
        vx: 0, // horizontal velocity
        acceleration: 1.5,
        friction: 0.92,
        maxVx: 15,
    };

    // --- Player Car ---
    const playerCar = {
        x: 0, y: 0, width: carWidth, height: carHeight, color: '#1E1E1E',
        draw() {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width / 2, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main car body with gradient
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, '#000');
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Windshield with reflection
            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(this.x + 5, this.y + 10, this.width - 10, 20);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(this.x + 7, this.y + 12, this.width - 14, 5);

            // Roof
            ctx.fillStyle = '#111111';
            ctx.fillRect(this.x + 2, this.y, this.width - 4, 10);

            // Headlights
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x + 5, this.y, 8, 8);
            ctx.fillRect(this.x + this.width - 13, this.y, 8, 8);
            
            // Taillights
            ctx.fillStyle = '#FF4141';
            ctx.fillRect(this.x + 5, this.y + this.height - 8, 8, 6);
            ctx.fillRect(this.x + this.width - 13, this.y + this.height - 8, 8, 6);
        }
    };
    
    // --- Game Initialization ---
    function init() {
        setCanvasSize();
        
        car = Object.assign({}, playerCar);
        car.color = selectedCarColor;
        car.x = gameWidth / 2 - car.width / 2;
        car.y = gameHeight - car.height - 20;

        obstacles = [];
        roadMarkings = [];
        skidMarks = [];
        score = 0;
        speed = initialSpeed;
        lastSpeedIncreaseScore = 0;
        carPhysics.vx = 0;
        gameOver = false;
        
        highScore = localStorage.getItem('endlessDriverHighScoreHD') || 0;
        highScoreElement.textContent = `Best: ${highScore}`;
        gameOverMenu.style.display = 'none';
        
        spawnInitialObstacles();
        spawnInitialRoadMarkings();

        playEngineSound();

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        lastTime = performance.now(); // For new game loop
        gameLoop();
    }
    
    function setCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gameWidth = canvas.width;
        gameHeight = canvas.height;
    }

    // --- High FPS Game Loop ---
    let lastTime = 0;
    let accumulator = 0;
    const fixedTimestep = 1 / 120; // Update physics 120 times a second

    function gameLoop(currentTime = 0) {
        if (gameOver) return;

        const deltaTime = (currentTime - lastTime) / 1000; // time in seconds
        lastTime = currentTime;
        accumulator += deltaTime;

        while (accumulator >= fixedTimestep) {
            update(fixedTimestep);
            accumulator -= fixedTimestep;
        }

        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Update Game State (Physics) ---
    function update(dt) { // dt is fixed timestep
        // Car horizontal movement
        if (keys['ArrowLeft'] || keys['a']) {
            if (carPhysics.vx > -carPhysics.maxVx) carPhysics.vx -= carPhysics.acceleration;
        }
        if (keys['ArrowRight'] || keys['d']) {
            if (carPhysics.vx < carPhysics.maxVx) carPhysics.vx += carPhysics.acceleration;
        }
        carPhysics.vx *= carPhysics.friction;
        car.x += carPhysics.vx * (dt * 60); // Normalized movement to feel consistent at any framerate

        // Add skid marks on sharp turns
        if (Math.abs(carPhysics.vx) > 5 && Math.random() > 0.5) {
             skidMarks.push({ x: car.x + 5, y: car.y + carHeight, life: 20 });
             skidMarks.push({ x: car.x + carWidth - 5, y: car.y + carHeight, life: 20 });
        }
        skidMarks.forEach(skid => skid.life--);
        skidMarks = skidMarks.filter(skid => skid.life > 0);


        // Clamp car position to road
        car.x = Math.max(0, car.x);
        car.x = Math.min(gameWidth - car.width, car.x);

        // Update score and speed
        score += speed / 50 * (dt * 60); // Normalize score to 60fps
        scoreElement.textContent = `Score: ${Math.floor(score)}`;
        if (score > lastSpeedIncreaseScore + speedIncreaseInterval) {
            speed = Math.min(maxSpeed, speed + 0.5);
            lastSpeedIncreaseScore += speedIncreaseInterval;
            updateEnginePitch(speed);
        }
        
        // Move road markings
        const worldSpeed = speed * (dt * 60);
        roadMarkings.forEach(m => m.y += worldSpeed);
        roadMarkings = roadMarkings.filter(m => m.y < gameHeight);
        if (roadMarkings.length === 0 || roadMarkings[roadMarkings.length-1].y > 80) {
            spawnRoadMarking();
        }
        
        // Move obstacles
        obstacles.forEach(o => o.y += worldSpeed);
        while (obstacles.length > 0 && obstacles[0].y > gameHeight) {
            obstacles.shift();
            spawnObstacle();
        }

        // Collision detection
        obstacles.forEach(obstacle => {
            if (car.x < obstacle.x + obstacle.width && car.x + car.width > obstacle.x && car.y < obstacle.y + obstacle.height && car.y + car.height > obstacle.y) {
                endGame();
            }
        });
    }

    // --- Drawing (Rendering) ---
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, gameWidth, gameHeight);

        // Draw skid marks
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        skidMarks.forEach(skid => ctx.fillRect(skid.x - 1, skid.y, 2, 10));

        // Draw road markings
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        roadMarkings.forEach(m => {
            ctx.fillRect(m.x, m.y, 5, 40);
        });

        // Draw obstacles
        obstacles.forEach(obstacle => drawObstacle(obstacle));
        
        // Draw car
        car.draw();
    }

    // --- Spawning Logic ---
    const roadShoulderWidth = () => 0; // Road is fullscreen
    const roadWidth = () => gameWidth - 2 * roadShoulderWidth();

    function spawnObstacle() {
        const blockTwoLanes = score > 100 && Math.random() > 0.6; // 40% chance to block two lanes after score 100

        if (blockTwoLanes) {
            // Guarantee a path by deciding which lane will be safe first
            const safeLane = Math.floor(Math.random() * 3);
            for (let i = 0; i < 3; i++) {
                if (i !== safeLane) {
                    createObstacleInLane(i);
                }
            }
        } else {
            // Block only one lane
            const laneToBlock = Math.floor(Math.random() * 3);
            createObstacleInLane(laneToBlock);
        }
    }

    function createObstacleInLane(lane) {
         const obstacleTypes = [
            { type: 'boulder', width: 70, height: 60 },
            { type: 'plank', width: 120, height: 25 },
            { type: 'puddle', width: 80, height: 40 },
            { type: 'oilSlick', width: 70, height: 50 },
            { type: 'cone', width: 30, height: 50 },
            { type: 'barrier', width: roadWidth() / 3 - 20, height: 35 },
        ];
        const selectedType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        const laneCount = 3;
        const laneWidth = roadWidth() / laneCount;
        const xPos = roadShoulderWidth() + (lane * laneWidth) + (laneWidth / 2) - (selectedType.width / 2);

        let newY = -selectedType.height - Math.random() * 300 - 150;
        obstacles.push({ x: xPos, y: newY, ...selectedType });
    }
    
    function spawnRoadMarking() {
        const line1x = gameWidth / 3 - 2.5;
        const line2x = (gameWidth * 2) / 3 - 2.5;
        roadMarkings.push({ x: line1x, y: -40 });
        roadMarkings.push({ x: line2x, y: -40 });
    }

    function drawObstacle(obstacle) {
        // Draw shadow first
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height, obstacle.width / 2, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        if (obstacle.type === 'boulder') {
             const grad = ctx.createLinearGradient(obstacle.x, obstacle.y, obstacle.x + obstacle.width, obstacle.y + obstacle.height);
             grad.addColorStop(0, '#8B8989'); // Lighter gray
             grad.addColorStop(1, '#5C5C5C'); // Darker gray
             ctx.fillStyle = grad;
             ctx.beginPath();
             ctx.moveTo(obstacle.x + obstacle.width * 0.1, obstacle.y + obstacle.height);
             ctx.lineTo(obstacle.x, obstacle.y + obstacle.height * 0.6);
             ctx.lineTo(obstacle.x + obstacle.width * 0.3, obstacle.y);
             ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y);
             ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.7);
             ctx.lineTo(obstacle.x + obstacle.width * 0.9, obstacle.y + obstacle.height);
             ctx.closePath();
             ctx.fill();
        } else if (obstacle.type === 'plank') {
            ctx.fillStyle = '#8B4513'; // SaddleBrown
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            // Wood grain
            ctx.strokeStyle = '#5A2D0C';
            ctx.lineWidth = 1;
            for(let i=0; i < obstacle.height; i += 5) {
                ctx.beginPath();
                ctx.moveTo(obstacle.x, obstacle.y + i);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + i);
                ctx.stroke();
            }
        } else if (obstacle.type === 'puddle') {
            ctx.fillStyle = 'rgba(30, 144, 255, 0.5)'; // DodgerBlue with transparency
            ctx.beginPath();
            ctx.ellipse(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            // Shimmer
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.3);
            ctx.bezierCurveTo(obstacle.x + obstacle.width * 0.4, obstacle.y + obstacle.height * 0.1, obstacle.x + obstacle.width * 0.6, obstacle.y + obstacle.height * 0.5, obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.4);
            ctx.stroke();
        } else if (obstacle.type === 'oilSlick') {
             ctx.fillStyle = 'rgba(20, 20, 20, 0.6)';
             ctx.beginPath();
             ctx.moveTo(obstacle.x, obstacle.y + obstacle.height * 0.5);
             ctx.bezierCurveTo(obstacle.x + obstacle.width * 0.3, obstacle.y, obstacle.x + obstacle.width * 0.7, obstacle.y, obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.6);
             ctx.bezierCurveTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height, obstacle.x, obstacle.y + obstacle.height, obstacle.x, obstacle.y + obstacle.height * 0.5);
             ctx.fill();
        } else if (obstacle.type === 'cone') {
            // Draw cone body
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.moveTo(obstacle.x + obstacle.width / 2, obstacle.y);
            ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
            ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
            ctx.closePath();
            ctx.fill();
            // Draw white stripes
            ctx.fillStyle = 'white';
            ctx.fillRect(obstacle.x, obstacle.y + obstacle.height * 0.3, obstacle.width, obstacle.height * 0.2);
            ctx.fillRect(obstacle.x, obstacle.y + obstacle.height * 0.7, obstacle.width, obstacle.height * 0.2);
        } else if (obstacle.type === 'barrier') {
            ctx.fillStyle = '#B22222';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            ctx.fillStyle = 'white';
            for(let i = 0; i < 5; i++) {
                ctx.save();
                ctx.translate(obstacle.x + i * (obstacle.width / 5), obstacle.y);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(0, 0, 10, 50);
                ctx.restore();
            }
        }
    }

    function spawnInitialObstacles() {
        obstacles = []; // Ensure the array is clean before starting
        let lastY = 0; // Reference point for spacing
        for (let i = 0; i < 5; i++) {
            const lane = Math.floor(Math.random() * 3);
            createObstacleInLane(lane);
            // Stagger the initial obstacles
            if(obstacles.length > 0) {
                const newY = lastY - (350 + Math.random() * 200);
                obstacles[obstacles.length-1].y = newY;
                lastY = newY;
            }
        }
    }

    function spawnInitialRoadMarkings() { 
        roadMarkings = [];
        const line1x = gameWidth / 3 - 2.5;
        const line2x = (gameWidth * 2) / 3 - 2.5;
        for(let i=-1; i*80 < gameHeight; i++) {
            roadMarkings.push({x: line1x, y: i*80});
            roadMarkings.push({x: line2x, y: i*80});
        }
    }

    // --- Game State Management ---
    function endGame() {
        gameOver = true;
        if (engineSound) engineSound.stop();
        playCrashSound();
        cancelAnimationFrame(animationFrameId);

        const finalScore = Math.floor(score);
        if (finalScore > highScore) {
            highScore = finalScore;
            localStorage.setItem('endlessDriverHighScoreHD', highScore);
            highScoreElement.textContent = `Best: ${highScore}`;
        }
        
        finalScoreElement.textContent = `Your Score: ${finalScore}`;
        gameOverMenu.style.display = 'block';
    }
    
    // --- Event Listeners ---
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        // Restart game with spacebar if game is over
        if (gameOver && (e.key === ' ' || e.code === 'Space')) {
            e.preventDefault(); // Prevent default spacebar action (like scrolling)
            gameOverMenu.style.display = 'none';
            init();
        }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    window.addEventListener('resize', () => {
        let oldWidth = gameWidth;
        setCanvasSize();
        car.x = (car.x / oldWidth) * gameWidth; // Recalculate car position
        spawnInitialRoadMarkings(); // Redraw markings for new size
    });

    restartButton.addEventListener('click', () => {
        gameOverMenu.style.display = 'none';
        init();
    });

    startButton.addEventListener('click', () => {
        if (!selectedCarColor) {
            alert("Please select a car color!");
            return;
        }
        initAudio(); // Initialize audio on first user interaction
        startMenu.style.display = 'none';
        gameArea.style.display = 'flex';
        init();
    });

    carSelectionContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('car-option')) {
            document.querySelectorAll('.car-option').forEach(el => el.classList.remove('selected'));
            e.target.classList.add('selected');
            selectedCarColor = e.target.dataset.color;
        }
    });

    // --- Auto-select first car ---
    const firstCar = carSelectionContainer.querySelector('.car-option');
    if (firstCar) {
        firstCar.classList.add('selected');
        selectedCarColor = firstCar.dataset.color;
    }
</script>

</body>
</html>



