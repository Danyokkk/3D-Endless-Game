<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Driver HD</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #FFA500;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #000000; /* Changed to black */
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background-color: #333; /* Asphalt color */
            display: block;
            border-radius: 10px;
            border: 2px solid #555;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .info-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2rem;
            z-index: 5;
        }
        .info-bar span {
            background: #111;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 30px var(--primary-color);
            z-index: 10;
        }
        .modal h2 {
            margin-top: 0;
            font-size: 2.5rem;
            color: var(--primary-color);
        }
        .modal p {
            font-size: 1.2rem;
        }
        .button {
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: var(--primary-color);
            color: #1a1a1a;
            border: none;
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            box-shadow: 0 0 15px var(--primary-color);
            transition: all 0.2s ease;
        }
        .button:hover {
            background-color: #fff;
            color: #000;
            box-shadow: 0 0 25px var(--primary-color);
        }
        #car-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .car-option {
            width: 50px;
            height: 90px;
            border: 3px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .car-option:hover, .car-option.selected {
            border-color: var(--primary-color);
            transform: scale(1.1);
        }
    </style>
</head>
<body>

<div id="splash-screen" class="modal">
    <h2>Made by Danik</h2>
</div>

<div id="start-menu" class="modal" style="display: none;">
    <h2>Endless Driver HD</h2>
    <p>Select your car:</p>
    <div id="car-selection">
        <div class="car-option" data-color="#1E1E1E" style="background-color: #1E1E1E;"></div>
        <div class="car-option" data-color="#B22222" style="background-color: #B22222;"></div>
        <div class="car-option" data-color="#1E90FF" style="background-color: #1E90FF;"></div>
        <div class="car-option" data-color="#228B22" style="background-color: #228B22;"></div>
    </div>
    <button id="start-button" class="button">Start Game</button>
</div>

<div class="game-container" id="game-area" style="display: none;">
    <div class="info-bar">
        <span id="score">Score: 0</span>
        <span id="high-score">Best: 0</span>
        <span id="global-high-score">Global Best: 0</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-over-menu" class="modal" style="display: none;">
        <h2>Game Over</h2>
        <p id="final-score">Your Score: 0</p>
        <button id="restart-button" class="button">Restart</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('high-score');
    const globalHighScoreElement = document.getElementById('global-high-score');
    const startMenu = document.getElementById('start-menu');
    const gameOverMenu = document.getElementById('game-over-menu');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    const startButton = document.getElementById('start-button');
    const carSelectionContainer = document.getElementById('car-selection');
    const gameArea = document.getElementById('game-area');
    const splashScreen = document.getElementById('splash-screen');

    // --- Splash Screen Logic ---
    window.addEventListener('load', () => {
        setTimeout(() => {
            splashScreen.style.display = 'none';
            startMenu.style.display = 'block';
        }, 2500); // Show splash for 2.5 seconds
    });

    // --- Firebase Setup ---
    let db;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-endless-driver';
    let globalHighScoreDocRef;
    let unsubscribeGlobalHighScore;

    async function initializeFirebase() {
        try {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            const auth = getAuth(app);
            await signInAnonymously(auth);
            globalHighScoreDocRef = doc(db, `/artifacts/${appId}/public/data/leaderboard`, "globalHighScore");
            listenToGlobalHighScore();
        } catch (e) {
            console.error("Firebase initialization failed. Global high scores will be unavailable.", e);
            globalHighScoreElement.textContent = "Global Best: N/A";
        }
    }
    initializeFirebase();

    function listenToGlobalHighScore() {
        if (!globalHighScoreDocRef) return;
        unsubscribeGlobalHighScore = onSnapshot(globalHighScoreDocRef, (doc) => {
            if (doc.exists()) {
                const data = doc.data();
                globalHighScoreElement.textContent = `Global Best: ${data.score || 0}`;
            } else {
                globalHighScoreElement.textContent = `Global Best: 0`;
            }
        });
    }

    async function updateGlobalHighScore(newScore) {
        if (!globalHighScoreDocRef) return;
        try {
            const docSnap = await getDoc(globalHighScoreDocRef);
            if (!docSnap.exists() || newScore > docSnap.data().score) {
                await setDoc(globalHighScoreDocRef, { score: newScore });
                console.log("New global high score set!");
            }
        } catch (error) {
            console.error("Error updating global high score: ", error);
        }
    }


    // --- Audio ---
    let audioCtx;
    let engineSound;

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playEngineSound() {
        if(!audioCtx) return;
        if (engineSound) {
            engineSound.stop();
        }
        engineSound = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        engineSound.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        engineSound.type = 'sawtooth';
        gainNode.gain.value = 0.05; // Keep volume low
        engineSound.frequency.value = 60; // Base pitch
        engineSound.start();
    }
    
    function playCrashSound() {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'noise';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.5);
    }
    
    function updateEnginePitch(currentSpeed) {
        if (!engineSound) return;
        const basePitch = 60;
        const maxPitch = 120;
        const pitch = basePitch + (currentSpeed / maxSpeed) * (maxPitch - basePitch);
        engineSound.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
    }

    // --- Game Configuration ---
    let gameWidth, gameHeight;
    const carWidth = 50;
    const carHeight = 90;
    const speedIncreaseInterval = 10;
    const initialSpeed = 4;
    const maxSpeed = 18;

    // --- Game State ---
    let car, obstacles, roadMarkings, sceneryObjects, skidMarks;
    let score, highScore, speed, lastSpeedIncreaseScore, selectedCarColor;
    let gameOver;
    let animationFrameId;
    let keys = {};
    
    // --- Car Physics ---
    const carPhysics = {
        vx: 0, // horizontal velocity
        acceleration: 1.5,
        friction: 0.92,
        maxVx: 15,
    };

    // --- Player Car ---
    const playerCar = {
        x: 0, y: 0, width: carWidth, height: carHeight, color: '#1E1E1E',
        draw() {
            // Main car body with gradient
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, '#000');
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Windshield with reflection
            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(this.x + 5, this.y + 10, this.width - 10, 20);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(this.x + 7, this.y + 12, this.width - 14, 5);

            // Roof
            ctx.fillStyle = '#111111';
            ctx.fillRect(this.x + 2, this.y, this.width - 4, 10);

            // Headlights
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x + 5, this.y, 8, 8);
            ctx.fillRect(this.x + this.width - 13, this.y, 8, 8);
            
            // Taillights
            ctx.fillStyle = '#FF4141';
            ctx.fillRect(this.x + 5, this.y + this.height - 8, 8, 6);
            ctx.fillRect(this.x + this.width - 13, this.y + this.height - 8, 8, 6);
        }
    };
    
    // --- Game Initialization ---
    function init() {
        setCanvasSize();
        
        car = Object.assign({}, playerCar);
        car.color = selectedCarColor;
        car.x = gameWidth / 2 - car.width / 2;
        car.y = gameHeight - car.height - 20;

        obstacles = [];
        roadMarkings = [];
        sceneryObjects = [];
        skidMarks = [];
        score = 0;
        speed = initialSpeed;
        lastSpeedIncreaseScore = 0;
        carPhysics.vx = 0;
        gameOver = false;
        
        highScore = localStorage.getItem('endlessDriverHighScoreHD') || 0;
        highScoreElement.textContent = `Best: ${highScore}`;
        gameOverMenu.style.display = 'none';
        
        spawnInitialObstacles();
        spawnInitialRoadMarkings();
        spawnInitialScenery();

        playEngineSound();

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop();
    }
    
    function setCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gameWidth = canvas.width;
        gameHeight = canvas.height;
    }

    // --- Game Loop ---
    function gameLoop() {
        if (gameOver) return;
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Update Game State ---
    function update() {
        // Car horizontal movement
        if (keys['ArrowLeft'] || keys['a']) {
            if (carPhysics.vx > -carPhysics.maxVx) carPhysics.vx -= carPhysics.acceleration;
        }
        if (keys['ArrowRight'] || keys['d']) {
            if (carPhysics.vx < carPhysics.maxVx) carPhysics.vx += carPhysics.acceleration;
        }
        carPhysics.vx *= carPhysics.friction;
        car.x += carPhysics.vx;

        // Add skid marks on sharp turns
        if (Math.abs(carPhysics.vx) > 5 && Math.random() > 0.5) {
             skidMarks.push({ x: car.x + 5, y: car.y + carHeight, life: 20 });
             skidMarks.push({ x: car.x + carWidth - 5, y: car.y + carHeight, life: 20 });
        }
        skidMarks.forEach(skid => skid.life--);
        skidMarks = skidMarks.filter(skid => skid.life > 0);


        // Clamp car position to road
        const roadShoulderWidth = gameWidth * 0.15;
        car.x = Math.max(roadShoulderWidth, car.x);
        car.x = Math.min(gameWidth - roadShoulderWidth - car.width, car.x);

        // Update score and speed
        score += speed / 50;
        scoreElement.textContent = `Score: ${Math.floor(score)}`;
        if (score > lastSpeedIncreaseScore + speedIncreaseInterval) {
            speed = Math.min(maxSpeed, speed + 0.2);
            lastSpeedIncreaseScore += speedIncreaseInterval;
            updateEnginePitch(speed);
        }
        
        // Move scenery
        sceneryObjects.forEach(obj => obj.y += speed * 0.8);
        sceneryObjects = sceneryObjects.filter(obj => obj.y < gameHeight);
        if (Math.random() < 0.05) spawnScenery();


        // Move road markings
        roadMarkings.forEach(m => m.y += speed);
        roadMarkings = roadMarkings.filter(m => m.y < gameHeight);
        if (roadMarkings.length === 0 || roadMarkings[roadMarkings.length-1].y > 80) {
            spawnRoadMarking();
        }
        
        // Move obstacles
        obstacles.forEach(o => o.y += speed);
        if (obstacles.length > 0 && obstacles[0].y > gameHeight) {
            obstacles.shift();
            spawnObstacle();
        }

        // Collision detection
        obstacles.forEach(obstacle => {
            if (car.x < obstacle.x + obstacle.width && car.x + car.width > obstacle.x && car.y < obstacle.y + obstacle.height && car.y + car.height > obstacle.y) {
                endGame();
            }
        });
    }

    // --- Drawing ---
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, gameWidth, gameHeight);

        // Draw scenery (grass, trees)
        const roadShoulderWidth = gameWidth * 0.15;
        ctx.fillStyle = '#006400'; // Dark Green for grass
        ctx.fillRect(0, 0, roadShoulderWidth, gameHeight);
        ctx.fillRect(gameWidth - roadShoulderWidth, 0, roadShoulderWidth, gameHeight);
        sceneryObjects.forEach(obj => {
            ctx.fillStyle = obj.color;
            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
        });

        // Draw skid marks
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        skidMarks.forEach(skid => ctx.fillRect(skid.x - 1, skid.y, 2, 10));

        // Draw road markings
        ctx.fillStyle = '#FFD700';
        roadMarkings.forEach(m => {
            ctx.fillRect(m.x, m.y, 5, 40);
        });

        // Draw obstacles
        obstacles.forEach(obstacle => drawObstacle(obstacle));
        
        // Draw car
        car.draw();
    }

    // --- Spawning Logic ---
    const roadShoulderWidth = () => gameWidth * 0.15;
    const roadWidth = () => gameWidth - 2 * roadShoulderWidth();

    function spawnObstacle() {
         const obstacleTypes = [
            { type: 'rock', color: '#696969', width: 60, height: 50 },
            { type: 'wood', color: '#8B4513', width: 90, height: 40 },
            { type: 'stick', color: '#A0522D', width: 20, height: 80 },
        ];
        const selectedType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        const laneCount = 3;
        const laneWidth = roadWidth() / laneCount;
        const lane = Math.floor(Math.random() * laneCount);
        const xPos = roadShoulderWidth() + (lane * laneWidth) + (laneWidth / 2) - (selectedType.width / 2);

        let newY = -selectedType.height - Math.random() * 300 - 150;
        obstacles.push({ x: xPos, y: newY, ...selectedType });
    }
    
    function spawnRoadMarking() {
        const centerX = gameWidth / 2 - 2.5;
        roadMarkings.push({ x: centerX, y: -40 });
    }

    function spawnScenery() {
        const side = Math.random() < 0.5 ? 'left' : 'right';
        const x = side === 'left' 
            ? Math.random() * (roadShoulderWidth() - 20)
            : gameWidth - roadShoulderWidth() + (Math.random() * (roadShoulderWidth() - 20));
        
        sceneryObjects.push({x: x, y: -50, width: 20, height: 50, color: '#004d00'});
    }

    function drawObstacle(obstacle) {
        ctx.fillStyle = obstacle.color;
        const grad = ctx.createLinearGradient(obstacle.x, obstacle.y, obstacle.x + obstacle.width, obstacle.y + obstacle.height);
        grad.addColorStop(0, obstacle.color);
        grad.addColorStop(1, '#2F4F4F');
        ctx.fillStyle = grad;

        if (obstacle.type === 'rock') {
             ctx.beginPath();
             ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
             ctx.quadraticCurveTo(obstacle.x + obstacle.width / 2, obstacle.y - obstacle.height / 2, obstacle.x + obstacle.width, obstacle.y + obstacle.height);
             ctx.closePath();
             ctx.fill();
        } else {
             ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }
    }

    function spawnInitialObstacles() {
        obstacles = []; // Ensure the array is clean before starting
        let lastY = 0; // Reference point for spacing
        for (let i = 0; i < 5; i++) {
            const obstacleTypes = [
                { type: 'rock', color: '#696969', width: 60, height: 50 },
                { type: 'wood', color: '#8B4513', width: 90, height: 40 },
                { type: 'stick', color: '#A0522D', width: 20, height: 80 },
            ];
            const selectedType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const laneCount = 3;
            const laneWidth = roadWidth() / laneCount;
            const lane = Math.floor(Math.random() * laneCount);
            const xPos = roadShoulderWidth() + (lane * laneWidth) + (laneWidth / 2) - (selectedType.width / 2);

            // Position them progressively further away off-screen
            const newY = lastY - (250 + Math.random() * 200); // 250px is a minimum gap
            obstacles.push({ x: xPos, y: newY, ...selectedType });
            lastY = newY;
        }
    }
    function spawnInitialRoadMarkings() { for(let i=-1; i*80 < gameHeight; i++) roadMarkings.push({x: gameWidth / 2 - 2.5, y: i*80}); }
    function spawnInitialScenery() { for(let i=0; i<10; i++) spawnScenery(); }


    // --- Game State Management ---
    function endGame() {
        gameOver = true;
        if (engineSound) engineSound.stop();
        playCrashSound();
        cancelAnimationFrame(animationFrameId);

        const finalScore = Math.floor(score);
        if (finalScore > highScore) {
            highScore = finalScore;
            localStorage.setItem('endlessDriverHighScoreHD', highScore);
            highScoreElement.textContent = `Best: ${highScore}`;
        }
        
        updateGlobalHighScore(finalScore);

        finalScoreElement.textContent = `Your Score: ${finalScore}`;
        gameOverMenu.style.display = 'block';
    }
    
    // --- Event Listeners ---
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        // Restart game with spacebar if game is over
        if (gameOver && (e.key === ' ' || e.code === 'Space')) {
            e.preventDefault(); // Prevent default spacebar action (like scrolling)
            gameOverMenu.style.display = 'none';
            init();
        }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    window.addEventListener('resize', () => {
        let oldWidth = gameWidth;
        setCanvasSize();
        car.x = (car.x / oldWidth) * gameWidth; // Recalculate car position
    });

    restartButton.addEventListener('click', () => {
        gameOverMenu.style.display = 'none';
        init();
    });

    startButton.addEventListener('click', () => {
        if (!selectedCarColor) {
            alert("Please select a car color!");
            return;
        }
        initAudio(); // Initialize audio on first user interaction
        startMenu.style.display = 'none';
        gameArea.style.display = 'flex';
        init();
    });

    carSelectionContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('car-option')) {
            document.querySelectorAll('.car-option').forEach(el => el.classList.remove('selected'));
            e.target.classList.add('selected');
            selectedCarColor = e.target.dataset.color;
        }
    });

    // --- Auto-select first car ---
    const firstCar = carSelectionContainer.querySelector('.car-option');
    if (firstCar) {
        firstCar.classList.add('selected');
        selectedCarColor = firstCar.dataset.color;
    }
</script>

</body>
</html>


