<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Driver 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --menu-highlight-color: #8A2BE2;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .info-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2rem;
            z-index: 5;
        }
        .info-bar span {
            background: #111;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .speedometer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.5rem;
            z-index: 5;
            border: 2px solid #333;
        }
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid var(--menu-highlight-color);
            box-shadow: 0 0 30px var(--menu-highlight-color);
            z-index: 10;
        }

        #game-over-menu, #danik-over-screen {
            text-transform: uppercase;
        }

        .modal h2 {
            margin-top: 0;
            font-size: 2.5rem;
            color: var(--menu-highlight-color);
            font-weight: 800;
        }
        
        .modal p {
            font-size: 1.2rem;
        }

        #game-over-menu p {
            font-weight: 800;
        }

        .button {
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #111;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            box-shadow: none;
            transition: all 0.2s ease;
        }
        .button:hover {
            background-color: #fff;
            color: #000;
        }
        #car-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .car-option {
            width: 50px;
            height: 90px;
            border: 3px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .car-option:hover, .car-option.selected {
            border-color: var(--menu-highlight-color);
            transform: scale(1.1);
        }

        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 6;
            pointer-events: none;
        }

        .touch-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
            user-select: none;
            pointer-events: all;
        }

        @media (max-width: 820px) {
            .touch-controls {
                display: flex;
            }
            .speedometer {
                /* Make space for touch controls on smaller screens */
                bottom: 120px;
            }
        }
    </style>
</head>
<body>

<div id="splash-screen" class="modal">
    <h2>Made by Danik</h2>
</div>

<div id="start-menu" class="modal">
    <h2>Endless Driver 3D</h2>
    <p>Select your car:</p>
    <div id="car-selection">
        <div class="car-option" data-color="#1E1E1E" style="background-color: #1E1E1E;"></div>
        <div class="car-option" data-color="#B22222" style="background-color: #B22222;"></div>
        <div class="car-option" data-color="#1E90FF" style="background-color: #1E90FF;"></div>
        <div class="car-option" data-color="#228B22" style="background-color: #228B22;"></div>
        <div class="car-option" data-color="#8A2BE2" style="background-color: #8A2BE2;"></div>
        <div class="car-option" data-color="#FF8C00" style="background-color: #FF8C00;"></div>
        <div class="car-option" data-color="#F5F5F5" style="background-color: #F5F5F5;"></div>
    </div>
    <button id="start-button" class="button">Start Game</button>
</div>

<div class="game-container" id="game-area" style="display: none;">
    <div class="info-bar">
        <span id="score">Score: 0</span>
        <span id="high-score">Best: 0</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="speedometer" class="speedometer">0 km/h</div>
    <div class="touch-controls">
        <div id="left-arrow" class="touch-button">&larr;</div>
        <div id="right-arrow" class="touch-button">&rarr;</div>
    </div>
    <div id="game-over-menu" class="modal" style="display: none;">
        <h2>Game Over</h2>
        <p id="final-score">Your Score: 0</p>
        <button id="restart-button" class="button">Restart</button>
    </div>
    <div id="danik-over-screen" class="modal" style="display: none;">
        <h2>Made by Danik</h2>
    </div>
</div>

<script type="module">
    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('high-score');
    const startMenu = document.getElementById('start-menu');
    const gameOverMenu = document.getElementById('game-over-menu');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    const startButton = document.getElementById('start-button');
    const carSelectionContainer = document.getElementById('car-selection');
    const gameArea = document.getElementById('game-area');
    const splashScreen = document.getElementById('splash-screen');
    const danikOverScreen = document.getElementById('danik-over-screen');
    const speedometerElement = document.getElementById('speedometer');
    const leftArrow = document.getElementById('left-arrow');
    const rightArrow = document.getElementById('right-arrow');

    // --- Splash Screen Logic ---
    window.addEventListener('load', () => {
        splashScreen.style.display = 'none';
        startMenu.style.display = 'block';
    });

    // --- Audio ---
    let audioCtx;
    let engineSound;

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playEngineSound() {
        if(!audioCtx) return;
        if (engineSound) engineSound.stop();
        engineSound = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        engineSound.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        engineSound.type = 'sawtooth';
        gainNode.gain.value = 0.05;
        engineSound.frequency.value = 60;
        engineSound.start();
    }
    
    function playCrashSound() {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'noise';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.5);
    }
    
    function updateEnginePitch(currentSpeed) {
        if (!engineSound) return;
        const basePitch = 60;
        const maxPitch = 120;
        const maxPitchSpeed = 50; 
        const pitchSpeed = Math.min(currentSpeed, maxPitchSpeed); 
        const pitch = basePitch + (pitchSpeed / maxPitchSpeed) * (maxPitch - basePitch);
        engineSound.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
    }

    // --- THREE.js Setup ---
    let scene, camera, renderer;
    let playerCarMesh, roadMesh;
    const roadLength = 400;

    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 10, 150);

        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 0);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        const roadGeometry = new THREE.PlaneGeometry(30, roadLength, 1, 1);
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
        roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
        roadMesh.rotation.x = -Math.PI / 2;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        const markingGeometry = new THREE.PlaneGeometry(0.5, 8);
        const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        for(let i = 0; i < roadLength / 20; i++) {
            const leftMarking = new THREE.Mesh(markingGeometry, markingMaterial);
            leftMarking.position.set(-5, 0.01, -i * 20 + roadLength / 2);
            leftMarking.rotation.x = -Math.PI / 2;
            roadMesh.add(leftMarking);

            const rightMarking = new THREE.Mesh(markingGeometry, markingMaterial);
            rightMarking.position.set(5, 0.01, -i * 20 + roadLength / 2);
            rightMarking.rotation.x = -Math.PI / 2;
            roadMesh.add(rightMarking);
        }
    }

    // --- Game Configuration ---
    let gameWidth, gameHeight;
    const carWidth = 3;
    const carHeight = 1.5;
    const carLength = 6;

    // --- Game State ---
    let obstacles = [];
    let score, highScore, speed, selectedCarColor;
    let gameOver;
    let animationFrameId;
    let keys = {};
    
    // --- Car Physics ---
    const carPhysics = {
        vx: 0,
        acceleration: 0.03, 
        friction: 0.975, 
        maxVx: 1.2, 
    };

    // --- Player Car ---
    function createCarMesh(color) {
        const carGroup = new THREE.Group();
        const bodyMat = new THREE.MeshStandardMaterial({ color });
        const bodyGeo = new THREE.BoxGeometry(carWidth, carHeight, carLength);
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        carGroup.add(bodyMesh);
        const cabinGeo = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.8, carLength * 0.4);
        const cabinMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const cabinMesh = new THREE.Mesh(cabinGeo, cabinMat);
        cabinMesh.position.set(0, carHeight * 0.8, -carLength * 0.1);
        carGroup.add(cabinMesh);
        return carGroup;
    }
    
    // --- Game Initialization ---
    function init() {
        setCanvasSize();
        
        obstacles.forEach(obsMesh => scene.remove(obsMesh));
        if(playerCarMesh) scene.remove(playerCarMesh);

        playerCarMesh = createCarMesh(selectedCarColor);
        playerCarMesh.position.set(0, carHeight / 2, 0);
        scene.add(playerCarMesh);

        obstacles = [];
        score = 0;
        speed = 0; // Start from 0
        carPhysics.vx = 0;
        gameOver = false;
        
        highScore = localStorage.getItem('endlessDriver3DHighScore') || 0;
        highScoreElement.textContent = `Best: ${highScore}`;
        gameOverMenu.style.display = 'none';
        
        spawnInitialObstacles();

        playEngineSound();

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        lastTime = performance.now();
        gameLoop();
    }
    
    function setCanvasSize() {
        gameWidth = window.innerWidth;
        gameHeight = window.innerHeight;
        renderer.setSize(gameWidth, gameHeight);
        camera.aspect = gameWidth / gameHeight;
        camera.updateProjectionMatrix();
    }

    // --- High FPS Game Loop ---
    let lastTime = 0;
    let accumulator = 0;
    const fixedTimestep = 1 / 120;

    function gameLoop(currentTime = 0) {
        if (gameOver) return;
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        accumulator += deltaTime;
        while (accumulator >= fixedTimestep) {
            update(fixedTimestep);
            accumulator -= fixedTimestep;
        }
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Update Game State (Physics) ---
    function update(dt) {
        if (keys['ArrowLeft'] || keys['a']) {
            if (carPhysics.vx > -carPhysics.maxVx) carPhysics.vx -= carPhysics.acceleration;
        }
        if (keys['ArrowRight'] || keys['d']) {
            if (carPhysics.vx < carPhysics.maxVx) carPhysics.vx += carPhysics.acceleration;
        }
        carPhysics.vx *= carPhysics.friction;
        playerCarMesh.position.x += carPhysics.vx;

        const roadBoundary = 13.5 - carWidth / 2;
        playerCarMesh.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, playerCarMesh.position.x));

        // --- SPEED AND SCORE LOGIC ---
        score += (15 + speed) * dt; 
        scoreElement.textContent = `Score: ${Math.floor(score)}`;

        const displaySpeed = Math.floor(score / 15) * 4;
        const targetSpeed = 10 + displaySpeed * 0.0625;

        // Smoothly accelerate towards the target speed
        if (speed < targetSpeed) {
            speed += 0.05; // Acceleration factor
            speed = Math.min(speed, targetSpeed);
        }
        updateEnginePitch(speed);
        
        const worldSpeed = speed * dt;
        
        obstacles.forEach(obsMesh => {
            obsMesh.position.z += worldSpeed;
        });

        obstacles = obstacles.filter(obsMesh => {
            if (obsMesh.position.z > camera.position.z + 20) {
                scene.remove(obsMesh);
                return false;
            }
            return true;
        });

        // --- OBSTACLE SPAWNING ---
        const obstacleTargetCount = score > 50 ? 9 : 6;
        if (obstacles.length < obstacleTargetCount) {
            let furthestZ = 0;
            if (obstacles.length > 0) {
                furthestZ = obstacles.reduce((min, obs) => Math.min(min, obs.position.z), 0);
            }
            
            const spacing = 100 + Math.random() * 50;
            const newWaveZ = furthestZ - spacing;

            const newWave = createObstacleWave(newWaveZ);
            obstacles.push(...newWave);
        }

        const carBBox = new THREE.Box3().setFromObject(playerCarMesh);
        obstacles.forEach(obstacleMesh => {
            const obstacleBBox = new THREE.Box3().setFromObject(obstacleMesh);
            if (carBBox.intersectsBox(obstacleBBox)) {
                endGame();
            }
        });
    }

    // --- Drawing (Rendering) ---
    function draw() {
        camera.position.x += (playerCarMesh.position.x - camera.position.x) * 0.1;
        
        const displaySpeed = Math.floor(score / 15) * 4;
        speedometerElement.textContent = `${displaySpeed} km/h`;

        renderer.render(scene, camera);
    }

    // --- Spawning Logic ---
    function createObstacleWave(zPos) {
        const newWave = [];
        const blockTwoLanes = score > 150 && Math.random() > 0.8; 
        
        if (blockTwoLanes) {
            const safeLane = Math.floor(Math.random() * 3);
            for (let i = 0; i < 3; i++) {
                if (i !== safeLane) {
                    newWave.push(spawnObstacleInLane(i, zPos));
                }
            }
        } else {
            const laneToBlock = Math.floor(Math.random() * 3);
            newWave.push(spawnObstacleInLane(laneToBlock, zPos));
        }
        return newWave;
    }

    function spawnObstacleInLane(lane, zPos) {
        const laneWidth = 10;
        const xPos = (lane - 1) * laneWidth;
        const obstacleMesh = createRandomObstacleMesh();
        obstacleMesh.geometry.computeBoundingBox();
        const height = obstacleMesh.geometry.boundingBox.max.y - obstacleMesh.geometry.boundingBox.min.y;
        const yPos = (obstacleMesh.geometry.type === 'CircleGeometry') ? 0.01 : height / 2;
        obstacleMesh.position.set(xPos, yPos, zPos);
        scene.add(obstacleMesh);
        return obstacleMesh;
    }

    function createRandomObstacleMesh() {
        const obstacleTypes = [ 'boulder', 'plank', 'puddle', 'cone', 'barrier' ];
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        let geo, mat;
        switch(type) {
            case 'boulder':
                geo = new THREE.IcosahedronGeometry(2, 0);
                mat = new THREE.MeshStandardMaterial({ color: 0x8B8989 });
                break;
            case 'plank':
                geo = new THREE.BoxGeometry(8, 0.5, 1);
                mat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                break;
            case 'puddle':
                geo = new THREE.CircleGeometry(3, 16);
                mat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.6 });
                break;
            case 'cone':
                geo = new THREE.CylinderGeometry(0, 1, 2, 8);
                mat = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
                break;
            case 'barrier':
                geo = new THREE.BoxGeometry(10, 1, 1);
                mat = new THREE.MeshStandardMaterial({ color: 0xB22222 });
                break;
        }
        const mesh = new THREE.Mesh(geo, mat);
        if (type === 'puddle') {
            mesh.rotation.x = -Math.PI / 2;
        } else {
            mesh.castShadow = true;
        }
        return mesh;
    }

    function spawnInitialObstacles() {
        obstacles = [];
        let lastZ = -50;
        for(let i = 0; i < 5; i++) {
            const wave = createObstacleWave(lastZ);
            obstacles.push(...wave);
            lastZ -= 100 + Math.random() * 50;
        }
    }

    // --- Game State Management ---
    function endGame() {
        if (gameOver) return;
        gameOver = true;
        if (engineSound) engineSound.stop();
        playCrashSound();
        cancelAnimationFrame(animationFrameId);
        danikOverScreen.style.display = 'block';
        setTimeout(() => {
            danikOverScreen.style.display = 'none';
            const finalScore = Math.floor(score);
            if (finalScore > highScore) {
                highScore = finalScore;
                localStorage.setItem('endlessDriver3DHighScore', highScore);
                highScoreElement.textContent = `Best: ${highScore}`;
            }
            finalScoreElement.textContent = `Your Score: ${finalScore}`;
            gameOverMenu.style.display = 'block';
        }, 2000);
    }

    function goBackToMenu() {
        gameOverMenu.style.display = 'none';
        gameArea.style.display = 'none';
        startMenu.style.display = 'block';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        if(engineSound) engineSound.stop();
    }
    
    // --- Event Listeners ---
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (gameOverMenu.style.display === 'block' && (e.key === ' ' || e.code === 'Space' || e.key === 'Enter')) {
            e.preventDefault();
            goBackToMenu();
        }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    window.addEventListener('resize', setCanvasSize);

    restartButton.addEventListener('click', goBackToMenu);

    startButton.addEventListener('click', () => {
        if (!selectedCarColor) {
            alert("Please select a car color!");
            return;
        }
        initAudio();
        startMenu.style.display = 'none';
        gameArea.style.display = 'flex';
        // Only init three.js once
        if(!scene) {
            initThree();
        }
        init();
    });

    carSelectionContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('car-option')) {
            document.querySelectorAll('.car-option').forEach(el => el.classList.remove('selected'));
            e.target.classList.add('selected');
            selectedCarColor = e.target.dataset.color;
        }
    });

    // --- Touch & Click Controls ---
    function handleLeftPress(e) {
        e.preventDefault();
        keys['ArrowLeft'] = true;
    }
    function handleLeftRelease(e) {
        e.preventDefault();
        keys['ArrowLeft'] = false;
    }
    function handleRightPress(e) {
        e.preventDefault();
        keys['ArrowRight'] = true;
    }
    function handleRightRelease(e) {
        e.preventDefault();
        keys['ArrowRight'] = false;
    }

    leftArrow.addEventListener('touchstart', handleLeftPress, { passive: false });
    leftArrow.addEventListener('touchend', handleLeftRelease);
    leftArrow.addEventListener('mousedown', handleLeftPress);
    leftArrow.addEventListener('mouseup', handleLeftRelease);
    leftArrow.addEventListener('mouseleave', handleLeftRelease);

    rightArrow.addEventListener('touchstart', handleRightPress, { passive: false });
    rightArrow.addEventListener('touchend', handleRightRelease);
    rightArrow.addEventListener('mousedown', handleRightPress);
    rightArrow.addEventListener('mouseup', handleRightRelease);
    rightArrow.addEventListener('mouseleave', handleRightRelease);

    const firstCar = carSelectionContainer.querySelector('.car-option');
    if (firstCar) {
        firstCar.classList.add('selected');
        selectedCarColor = firstCar.dataset.color;
    }
</script>

</body>
</html>


